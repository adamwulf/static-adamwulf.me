+++
title = "Introducing JotUI: An Open Source OpenGL Drawing view for iOS"
date = "2016-10-24T21:54:46+0000"
slug = "introducing-jotui-open-source-opengl-drawing-view-ios"
type = "post"
+++

<p>When I started working on <a href="https://itunes.apple.com/us/app/loose-leaf/id625659452?mt=8&amp;uo=4&amp;at=10lNUI&amp;ct=blog">Loose Leaf</a>, I quickly realized that the hardest part of the app was finding a fast and efficient drawing UIView that I could add into my app. There were a fair number of tutorials that would solve the first 80%, but there was always some important pieces left as an exercise for the reader: Smooth curves, removing lag and stutter, or main-thread-blocking save/load.</p>
<p>All of the code I found could do some, but not all, of the following:</p>
<ol>
<li>Nice smooth curving lines instead of rigid line segments</li>
<li>Variable width/opacity depending on pressure/velocity</li>
<li>Undo and Redo</li>
<li>Save and load asynchronously without lag while drawing</li>
<li>Low memory footprint</li>
</ol>
<p>After trying innumerable existing options, I decided to build my own drawing engine to solve <i>all</i> these features in 1 framework. The <a href="https://github.com/adamwulf/JotUI">JotUI framework</a> is the result.</p>
<p>If all you need is the drawing view, head straight to the <a href="https://github.com/adamwulf/JotUI">Github project page</a> for the code and sample project. If youâ€™re curious about how it was built and how I navigated those trade-offs, then read on below.</p>
<h2><a aria-hidden="true" class="aal_anchor" href="#building-a-drawing-view-for-ios" id="building-a-drawing-view-for-ios"><svg aria-hidden="true" class="aal_svg" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Building a Drawing View for iOS</h2>
<h3><a aria-hidden="true" class="aal_anchor" href="#smooth-curves" id="smooth-curves"><svg aria-hidden="true" class="aal_svg" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Smooth Curves</h3>
<p>For smooth curves, I had a few requirements that I wanted to keep:</p>
<ol>
<li>The line should always curve through the touch points exactly</li>
<li>The line should always pass through the most recently added point as soon as its added</li>
<li>Bonus points if its configurable for how hard/soft the smoothing is</li>
</ol>
<p>It turns out that doing all of those things is harder than it sounds!</p>
<p>After trying probably tens of options for a smoothing algorithm, I finally found a single algorithm that satisfied all of these constraints. The algorithm is defined <a href="http://www.antigrain.com/research/bezier_interpolation/">here by Maxim Shemanarev</a>, which I found through <a href="http://www.effectiveui.com/blog/2011/12/02/how-to-build-a-simple-painting-app-for-ios/">Sean Christmannâ€™s post</a>.</p>
<h4><a aria-hidden="true" class="aal_anchor" href="#the-code" id="the-code"><svg aria-hidden="true" class="aal_svg" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>The Code</h4>
<p>The smoothing code is integrated in <a href="https://github.com/adamwulf/JotUI/blob/master/JotUI/JotUI/SegmentSmoother.m">SegmentSmoother::addPoint:andSmoothness:</a>.</p>
<h3><a aria-hidden="true" class="aal_anchor" href="#pressure-and-velocity" id="pressure-and-velocity"><svg aria-hidden="true" class="aal_svg" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Pressure and Velocity</h3>
<p>Now that we have a nice curved Bezier path, itâ€™s time to add some body to it. At each touch point along the curve, I can use the pressure to determine the width at that point. So I only need to smooth between widths at each point â€“ shouldnâ€™t be too hardâ€¦. right?!</p>
<p><a href="https://code.tutsplus.com/tutorials/ios-sdk-advanced-freehand-drawing-techniques--mobile-15602">This post by Akeil Khan</a> describes the first strategy that I looked at. Essentially: at each point, find two points perpendicular to the line so that we can define the outline of the path, instead of its centerline. Then, in the case of Core Graphics, we can fill that path, or we can use a traingle stripe to render it in OpenGL.</p>
<p>Up until this point, I had been using Core Graphics to render my lines, but I found that the computation necessary to calculate this path outline and fill it was simply too slow for what I needed. This wasnâ€™t the fault of the outline algorithm as much as it was the performance of Core Graphics.</p>
<p>If I drew on the main thread, it was slow enough to lag the following touch inputs. And if I drew on the background thread, then the touch inputs wouldnâ€™t lag but the round trip from main=&gt;background=&gt;main for the view refresh was long enough that the stroke appeard to follow the userâ€™s finger after a delay. This also only let me interpolate between widths at each point, but I wasnâ€™t able to interpolate between opacity. Also, sharp turns â€“ like at the top of a cursive lowercase b or d â€“ had uncomfortably flat tops.</p>
<p>It was here that I found the <a href="https://developer.apple.com/library/content/samplecode/GLPaint/Introduction/Intro.html">GLPaint example app from Apple</a>. This example app doesnâ€™t smooth between touch points, doesnâ€™t use variable width or opacity for touch inputs, doesnâ€™t do much of anything that I need, <i>except</i>: it renders lines entirely differently than Core Graphics. Instead of filling a bounded shape with the same color, it draws tons of points along the line â€“ each point rendered independently of the one before it â€“ and together those points look and act like a single stroke.</p>
<p>I built on this base code, added in the smoothing algorithm from before, and researched how to add variable radius and opacity for each of the points along the path. With these additions, I had a viable rendering view that could:</p>
<ol>
<li>Smooth the curve between touch points</li>
<li>Interpolate width and opacity along the line</li>
<li>Bonus: Supports different brush textures and shapes</li>
</ol>
<h4><a aria-hidden="true" class="aal_anchor" href="#the-code" id="the-code"><svg aria-hidden="true" class="aal_svg" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>The Code</h4>
<p>The code for this is in <a href="https://github.com/adamwulf/JotUI/blob/master/JotUI/JotUI/CurveToPathElement.m">CurveToPathElement::generatedVertexArrayWithPreviousElement:forScale:</a>.</p>
<p>Next up was undo &amp; redo, saving asynchronously, and optimizing for memory.</p>
<h3><a aria-hidden="true" class="aal_anchor" href="#undo-and-redo" id="undo-and-redo"><svg aria-hidden="true" class="aal_svg" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Undo and Redo</h3>
<p>The example app from Apple didnâ€™t support undo/redo, it just wrote directly to an OpenGL viewâ€™s layer â€“ not even something I knew how to quickly/easily get a PNG out of. Despite that, I was able to add in undo/redo support by adding in a cache of stroke objects before they were written to the underlying texture.</p>
<p>Instead of only writing directly to the viewâ€™s context, I also added in a backing texture context. Every time the userâ€™s finger/stylus lifed from the screen, Iâ€™d push another stroke onto a queue. After the queue grew longer than the max undo count, Iâ€™d write a stroke from the queue to the permanent backing texture â€“ exactly the same as if I was writing to the screen, except this time it was to a separate texture.</p>
<p>Then, if the user wanted to undo a stroke, I could calculate the bounding rect of the top stroke on the queue, clip the screen rendering to that box, draw the base texture and then all of the strokes still in the undo queue. Doing something like this in Core Graphics would take 100s of milliseconds, but doing it directly in OpenGL was significantly faster â€“ I was super excited by how quickly I could undo and redo multiple strokes one after another without any noticeable lag for the user.</p>
<h4><a aria-hidden="true" class="aal_anchor" href="#the-code" id="the-code"><svg aria-hidden="true" class="aal_svg" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>The Code</h4>
<p>The code for this is in <a href="https://github.com/adamwulf/JotUI/blob/master/JotUI/JotUI/JotView.m">JotView::undo</a>.</p>
<h3><a aria-hidden="true" class="aal_anchor" href="#saving-and-loading-asynchronously" id="saving-and-loading-asynchronously"><svg aria-hidden="true" class="aal_svg" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Saving and Loading Asynchronously</h3>
<p>At this point, I had an OpenGL view that had an OpenGL texture and a stack of OpenGL points sitting in memory, and I needed a way to get these out of memory and on to disk as quickly as possible while still allowing the main thread to write to and mutate these datastructures.</p>
<p>I setup a background timer that would fire a method continuously on a background thread. If the undo queue was larger than the max number of undo items, then that background would: lock reading from the base texture, render undo items onto that base texture until the count was back below the maximum number, then unlock on the background texture. This meant that the main thread and background threads would wait on each other if either was trying to write/read the background texture.<br/>
To make sure the background thread never entirely blocked the main thread, I a set limits on the number of undo items to render â€“ so if the background thread was taking too long it would punt back to the main thread and just pick up where it left off next time the timer fired. This kept the main thread responsive no matter how much data was queued to be written to disk.</p>
<h4><a aria-hidden="true" class="aal_anchor" href="#the-code" id="the-code"><svg aria-hidden="true" class="aal_svg" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>The Code</h4>
<p>The code for this is in <a href="https://github.com/adamwulf/JotUI/blob/master/JotUI/JotUI/JotView.m">JotView::validateUndoState</a>.</p>
<h3><a aria-hidden="true" class="aal_anchor" href="#keeping-memory-low" id="keeping-memory-low"><svg aria-hidden="true" class="aal_svg" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Keeping Memory Low</h3>
<p>In addition to optimizing CPU performance and keeping the main thread as clear as possible, I also aimed for the library to keep a very low memory footprint. A drawing view isnâ€™t helpful if after a few saves and loads it crashes the app because of high memory â€“ and working with uncompressed retina-screen sized textures meant this was a real threat.</p>
<p>I worked to optimize memory use in two different ways:</p>
<ol>
<li>minimizing the data for rendering each stroke</li>
<li>re-using full-screen textures when possible</li>
</ol>
<p>As I worked to minimize memory use, I found that even if I was diligently freeing unneeded memory â€“ that didnâ€™t mean that the system would reuse that memory on a later malloc(). And it makes sense in retrospect: If I allocate/deallocate memory quickly over and over and over, the system is going to have a harder and harder time finding chunks of memory to give me as the pages of memory become more fragmented. Stroke data makes this issue even more apparently, there are lots of strokes to allocate, each made up of lots of smaller chunks to allocate, meaning lots and lots of malloc() and dealloc() of very small pieces of memory.</p>
<p>To combat this, I setup two caches: one for screen-sized textures, and one for the stroke data.</p>
<h4><a aria-hidden="true" class="aal_anchor" href="#texture-cache" id="texture-cache"><svg aria-hidden="true" class="aal_svg" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Texture Cache</h4>
<p>In the texture cache, I know that Iâ€™m only ever going to create textures up-to the size of the screen, but never larger. In some situations, like generating thumbnails, I may generate smaller textures, but never larger ones. To prevent multiple allocation/deallocations, I only ever memory chunks large enough to fit an entire screen texture into memory. Since smaller textures can only use smaller amounts of memory, itâ€™s safe to just return that 1 single sized block of memory for any texture use.</p>
<p>This way, small textures do get too much memory sometimes, but only briefly before they return it to the cache. Only a few textures are ever alive at a time, keeping total texture allocation very small.</p>
<h4><a aria-hidden="true" class="aal_anchor" href="#stroke-cache" id="stroke-cache"><svg aria-hidden="true" class="aal_svg" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Stroke Cache</h4>
<p>Each stroke is composed of smaller stroke segments, and each segment handles its own malloc() to store its pointsâ€™ data. Since segments are fairly small, maybe a few hundred bytes, I first tried allocating these small chunks of memory independently. Interestingly, even if I only malloc()â€™d 100 bytes, I found that the smallest amount of memory allocated was always a 2kb page. And just like the texture cache, I found that the system was more apt to allocate fresh blocks of memory for new allocations instead of reusing old freed memory. For hundreds of segments across hundreds of strokes during a drawing session, this could add up in a hurry.</p>
<p>To optimize this, I setup a two layered cache: one for the 2kb blocks of memory, and another for smaller units of that 2kb chunk. This let a 2kb allocation in the first cache be used as 4 500 byte items in the 2nd cache, or even 20 100 byte items. In this way, the stroke cache was kept much much smaller than it wouldâ€™ve been otherwise, and caused far less church and fragmentation in memory as well.</p>
<h4><a aria-hidden="true" class="aal_anchor" href="#the-code" id="the-code"><svg aria-hidden="true" class="aal_svg" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>The Code</h4>
<p>The code for the texture cache is in <a href="https://github.com/adamwulf/JotUI/blob/master/JotUI/JotUI/JotTextureCache.m">JotTextureCache</a>, and the code for the stroke cache is in the <a href="https://github.com/adamwulf/JotUI/blob/master/JotUI/JotUI/JotBufferManager.m">JotBufferManager</a>.</p>
<h3><a aria-hidden="true" class="aal_anchor" href="#summary" id="summary"><svg aria-hidden="true" class="aal_svg" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Summary</h3>
<p>Thereâ€™s lots more love that has gone into JotUI that I havenâ€™t talked about here â€“ things like CPU optimization, brush textures, brush rotation, file and disk caching, and a lot more â€“ but I hope this gives you a taste for whatâ€™s in the repo.</p>
<p>If you decide to use JotUI in one of your projects, Iâ€™ve love for you to reach out and let me know <a href="http://twitter.com/adamwulf">@adamwulf</a>!</p>
<p>And of course â€“ support more open source code and download <a href="https://itunes.apple.com/us/app/loose-leaf/id625659452?mt=8&amp;uo=4&amp;at=10lNUI&amp;ct=website">Loose Leaf</a> today! ðŸ™‚</p>