+++
title = "Distributed Clocks and CRDTs"
date = "2021-05-17T04:11:23+0000"
slug = "distributed-clocks-and-crdts"
type = "post"
+++

<p>At <a href="https://museapp.com/">Muse</a> we’ve been thinking a lot about conflict-free replicated data types, and how they might enable <a href="https://www.inkandswitch.com/local-first.html">local-first</a> sync across devices. <a href="https://github.com/automerge">Automerge</a>, out of the <a href="https://www.inkandswitch.com/">Ink and Switch labs</a>, has done incredible work building a sophisticated CRDT implementation.</p>
<p>I learn best by getting my hands dirty and building. As I’ve been learning about CRDTs, the first piece that caught my eye was the various clocks that can be used to keep disconnected peers aligned with each other.</p>
<p>If I edit an object on one device, and then edit that same object on another device, and then sync both devices together. I want to be 100% confident that both devices see those edits in the exact same order. This is what allows “conflict free” in CRDT. Distributed clocks provide this guaranteed ordering agreement.</p>
<p>I’ve started building various clocks for use in CRDTs in Swift in the <a href="https://github.com/adamwulf/Clocks">Clocks Swift Package on Github</a>.</p>
<h2 class="wp-block-heading"><a aria-hidden="true" class="aal_anchor" href="#last-write-wins" id="last-write-wins"><svg aria-hidden="true" class="aal_svg" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Last Write Wins</h2>
<p>The simplest CRDT is simply a last-write-wins map. That is, for any given value in my data structure, I only update the value when what i’m receiving is more recent than the current value. So if a count is set to 11 at time T<sub>2</sub>, and then I receive an event setting it to 17 at time T<sub>3</sub>, I would update the value to 17. But then if I hear an event setting the value to 5 at time T<sub>1</sub>, I would ignore that change since I’m already at time T<sub>3</sub>. Every atomic value in the data structure is essentially a tuple of its value and the last time it was changed.</p>
<p>This means that the clocks on the different clients need to be able to correctly order all events from all other clients, adjust and account for any clock drift, and even account for a bad-actor (intentional or accidental) where the clock might be ahead or behind by a significant amount of time. If my laptop is somehow 24 hours ahead and I make a change, I don’t want my iPad to have to wait 24 hours before it’s slower clock finally catches up before I’m able to make additional edits.</p>
<h2 class="wp-block-heading"><a aria-hidden="true" class="aal_anchor" href="#world-clock" id="world-clock"><svg aria-hidden="true" class="aal_svg" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>World Clock</h2>
<p>An important question, then, is how do we define the timestamps T<sub>1</sub>, T<sub>2</sub>, and T<sub>3</sub>? We could use a UTC timestamp, though there are a few downsides: some clients might not be perfectly synchronized, and could be minutes or hours ahead of another client. If my device had its system clock set a day ahead, and I make an edit, then no other devices would be able to make a change for 24 hours as their system clocks would all be ‘before’ the edit.</p>
<p>Another problem with timestamps is that they might exactly overlap. Using seconds as the accuracy of the timestamp will almost certainly have events sharing the exact same timestamp, making ordering impossible. Using milliseconds helps, but could still cause sync issues, particularly in realtime collaboration settings. Even within a single client, many events might be generated at the same instant, yielding events with identical timestamps.</p>
<p>What we really want is a notion of a timestamp that is always:</p>
<ul class="wp-block-list"><li>unique from any other timestamp</li><li>orderable compared to any other timestamp</li><li>monotonically increasing so that we can generate new timestamps after existing ones</li><li>does not require clients to collaborate. Both clients will agree on an event ordering, even if their first communication is after they generate all of their event timestamps.</li></ul>
<p>Below is a few different clocks I’ve been learning about, each of which accomplishes the above to a varying degree. I’ve implemented each of these in Swift in the <a href="https://github.com/adamwulf/Clocks">Clocks Swift Package on Github</a>.</p>
<h2 class="wp-block-heading"><a aria-hidden="true" class="aal_anchor" href="#lamport-clocks" id="lamport-clocks"><svg aria-hidden="true" class="aal_svg" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Lamport Clocks</h2>
<p>Lamport clocks are perhaps the simplest clocks to start us off – they are essentially just a counter. The counter starts at 1, and every time an event occurs the counter is incremented. Whenever a message is received, the counter is incremented above the max of the local and remote value. <a href="https://miafish.wordpress.com/2015/03/11/lamport-vector-clocks/#comments">This post by Miafish</a> has a great explanation and diagram explaining Lamport clocks.</p>
<p>The diagram below from <a href="https://en.wikipedia.org/wiki/Lamport_timestamp">the Wikipedia article</a> shows how three clients each with independent clocks can all agree on the ordering of each other’s events, and are able to order all events before or after event B4.</p>
<div class="wp-block-image"><figure class="aligncenter size-large"><img alt="" class="wp-image-5455" decoding="async" fetchpriority="high" height="603" sizes="(max-width: 1024px) 100vw, 1024px" src="/wp-content/uploads/2021/05/1280px-Lamport-Clock-en-1024x603.png" srcset="/wp-content/uploads/2021/05/1280px-Lamport-Clock-en-1024x603.png 1024w, /wp-content/uploads/2021/05/1280px-Lamport-Clock-en-300x177.png 300w, /wp-content/uploads/2021/05/1280px-Lamport-Clock-en-768x452.png 768w, /wp-content/uploads/2021/05/1280px-Lamport-Clock-en.png 1280w" width="1024"/><figcaption>Lamport clock timeline diagram<br/>CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=888307</figcaption></figure></div>
<p>In some ways, this is extremely similar to using timestamps, except instead of using UTC seconds, an increasing integer counter is used. This prevents a client from generating duplicate timestamps from its own clock, which could happen by using world time, but doesn’t solve the issue of two clients generating the same timestamp independently. In the above diagram, both device B and device C create an event at time 6 (B4 and C3). Which event came first? Using a unique client identifier to break the tie is a fairly good solution. Each client can generate a UUID, and then any events with the same Lamport clock value can be sorted based on the UUID of its originating client.</p>
<h2 class="wp-block-heading"><a aria-hidden="true" class="aal_anchor" href="#vector-clocks" id="vector-clocks"><svg aria-hidden="true" class="aal_svg" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Vector Clocks</h2>
<p><a href="https://en.wikipedia.org/wiki/Vector_clock">Vector clocks</a> are essentially multi-dimensional Lamport clocks. Instead of each client updating a shared Lamport clock with the largest-yet-seen value, each client maintains its own clock and increments it whenever a local change occurs. Upon hearing of events from other clients, the clock is updated to record both its and any other heard clocks – so the single clock becomes a vector of multiple clocks.</p>
<p>Whenever a message is received from another client, it increments its own clock for each change, and stores the max value of all other clocks along with it. Miafish’s post that I mentioned above also <a href="https://miafish.wordpress.com/2015/03/11/lamport-vector-clocks/">does a great job explaining vector clocks</a> in a simple and clear way.</p>
<p>A timestamp in Clock A is said to be before another a timestamp in Clock B if:</p>
<ol class="wp-block-list"><li>All vector values in clock A are less than or equal to clock B</li><li>At least one value in clock A is less than the corresponding value in Clock B</li></ol>
<p>This gives vector clocks an interesting property – they can determine if an event occurred before any other event, but also can determine if an event happened ‘simultaneously’ with another event. In the diagram below, the event B3C2 (in C’s client) happens in parallel with event A2B4C1 (in B’s client), as the C count is larger in B3C2, but the B count is smaller.</p>
<div class="wp-block-image"><figure class="aligncenter size-large"><img alt="" class="wp-image-5456" decoding="async" height="579" sizes="(max-width: 1024px) 100vw, 1024px" src="/wp-content/uploads/2021/05/2880px-Vector_Clock-1024x579.png" srcset="/wp-content/uploads/2021/05/2880px-Vector_Clock-1024x579.png 1024w, /wp-content/uploads/2021/05/2880px-Vector_Clock-300x170.png 300w, /wp-content/uploads/2021/05/2880px-Vector_Clock-768x434.png 768w, /wp-content/uploads/2021/05/2880px-Vector_Clock-1536x869.png 1536w, /wp-content/uploads/2021/05/2880px-Vector_Clock-2048x1158.png 2048w" width="1024"/><figcaption>Vector clock timeline diagram.<br/>CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid=1187502</figcaption></figure></div>
<h2 class="wp-block-heading"><a aria-hidden="true" class="aal_anchor" href="#hybrid-logical-clocks" id="hybrid-logical-clocks"><svg aria-hidden="true" class="aal_svg" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Hybrid Logical Clocks</h2>
<p>Surprisingly, Wikipedia does not have an article for Hybrid Logical Clocks, but the <a href="https://jaredforsyth.com/posts/hybrid-logical-clocks/">post by Jared Forsyth</a> based on the <a href="https://www.dotconferences.com/2019/12/james-long-crdts-for-mortals">talk by James Long</a> is a fantastic reference of how they work.</p>
<p>Hybrid logical clocks build upon the foundation of the Lamport clock, and add in a wall clock component as well. This clock has three components: a wall clock time, a counter, and the clock’s unique identifier. In the exceptionally rare instance that two clock’s wall time and counter match, the identifier will break the tie.</p>
<p>Here’s how the clock works:</p>
<ul class="wp-block-list"><li>Initialize the clock with the current UTC timestamp and a counter of zero</li><li>Whenever an event happens:<ul><li>If the current wall clock time is after the current HLC timestamp, then update the timestamp and reset the counter to zero</li><li>If the current wall clock time is before or equal to the current HLC timestamp, leave the timestamp unchanged and increment the counter</li></ul></li><li>Whenever an event is received:<ul><li>if the local wall clock time is larger than both our HLC and the event’s HLC, then use that and reset the counter to 0, otherwise, the wall clock is at or before our time, so we can ignore it</li><li>if our HLC timestamp is equal to the event’s HLC timestamp, set our counter to one more than the max of both our counters</li><li>if our HLC timestamp is after the event’s HLC timestamp, keep our timestamp and increment our counter</li><li>last, if the event’s HLC timestamp is larger than our timestamp, use it’s timestamp and set our counter to 1 larger than its count</li></ul></li></ul>
<p>What’s so nice about this clock is that it’s extremely easy to implement, the rules are straightforward and easy to read and debug. Each moment recorded by the HLC has a wall-clock timestamp component, so it’s also easy to see roughly when in real-world time an event occurred. And all events from all clients can be uniquely ordered, with every client agreeing on the ordering of events without the need for a central-server arbiter.</p>
<p>What’s particularly nice about this clock, too, is how it handles a misbehaving wall clock. <a href="https://jaredforsyth.com/posts/hybrid-logical-clocks/">Jared does a great job explaining why</a>:</p>
<blockquote class="wp-block-quote">
<p>Let’s be clear up-front about the promises this clock is making; it cannot divine the actual real-life ordering of all events. It does however make the following guarantees:</p>
<ol>
<li>All events created on a single machine will be correctly ordered with respect to each other (even if the wall clock jumps back a second or is otherwise squirrely).</li>
<li>Once machine A sends events to machine B, all events subsequently created on machine B will be ordered as <em>after</em> those events from machine A. So if A sets their clock one day ahead, makes some changes, and sends them to B, B will still be able to make changes even though its own wall clock is ‘behind’.</li>
</ol>
<p><a href="https://jaredforsyth.com/posts/hybrid-logical-clocks/"><cite>https://jaredforsyth.com/posts/hybrid-logical-clocks/</cite></a></p></blockquote>
<p>When I learned about these clocks, it almost felt like I’d somehow gained a new superpower! I didn’t need to run a central server or rely on accurate wall clocks to get a sane order of events from disconnected peers. This is a simple and resilient way to guarantee ordering of events between multiple distributed actors.</p>
<h2 class="wp-block-heading"><a aria-hidden="true" class="aal_anchor" href="#swift-clocks-package" id="swift-clocks-package"><svg aria-hidden="true" class="aal_svg" height="16" version="1.1" viewbox="0 0 16 16" width="16"><path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z" fill-rule="evenodd"></path></svg></a>Swift Clocks Package</h2>
<p>I had a lot of fun learning about these clock types, and I’ve coded each of them up in Swift. <a href="https://github.com/adamwulf/Clocks">The Clocks repository</a> contains Swift implementations of Lamport, vector, and hybrid logical clocks. </p>
<p>Import as a swift package using:</p>
<pre class="wp-block-code"><code>https://github.com/adamwulf/Clocks.git</code></pre>