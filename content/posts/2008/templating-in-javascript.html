+++
title = "Templating in JavaScript"
date = "2008-07-17T01:57:43+0000"
slug = "templating-in-javascript"
type = "post"
+++

<p>John Resig <a href="http://ejohn.org/blog/javascript-micro-templating/">released a small script</a> that letâ€™s you easily do some â€œquick-and-dirtyâ€ templating on the client side. I love the idea, but Iâ€™m less than a fan of the implementation, but Iâ€™ll get to that in a minute. First the love: This small script lets you essentially copy and paste some HTML and hot swap out new data as itâ€™s [presumably] ajaxâ€™d in, and that is incredibly handy. You even get fancy template style syntax like â€œ&lt;% for(..) %&gt;â€ So how is this done?</p>
<p>Templates are be defined in script blocks (notice the type attribute):</p>
<pre class="wp-block-preformatted">&lt;script type="text/html" id="user_tmpl"&gt;<br/>&lt;% for ( var i = 0; i &lt; users.length; i++ ) { %&gt;&lt;/p&gt;<br/>&lt;li&gt;&lt;a href="&lt;%=users[i].url%&gt;"&gt;&lt;%=users[i].name%&gt;&lt;/a&gt;&lt;/li&gt;<br/>&lt;/p&gt;&lt;% } %&gt;</pre>
<p>And to use the template is simply:</p>
<pre class="wp-block-preformatted">var results = document.getElementById("results");<br/>results.innerHTML = tmpl("item_tmpl", dataObject);</pre>
<p>Itâ€™s easy, to be sure, and the results are slick. Iâ€™ve found myself needing to do this sort of copy/paste of DOM structure many many many times when building <a href="https://www.jotlet.net/">Jotlet</a>. So why donâ€™t I like it? Well letâ€™s take a look at the magic that makes this possible:</p>
<pre class="wp-block-preformatted">// Simple JavaScript Templating<br/>// John Resig - http://ejohn.org/ - MIT Licensed<br/>(function(){<br/>var cache = {};<br/><br/>this.tmpl = function tmpl(str, data){<br/>// Figure out if we're getting a template, or if we need to<br/>// load the template - and be sure to cache the result.<br/>var fn = !/W/.test(str) ?<br/>cache[str] = cache[str] ||<br/>tmpl(document.getElementById(str).innerHTML) :<br/><br/>// Generate a reusable function that will serve as a template<br/>// generator (and which will be cached).<br/>new Function("obj",<br/>"var p=[],print=function(){p.push.apply(p,arguments);};" +<br/><br/>// Introduce the data as local variables using with(){}<br/>"with(obj){p.push('" +<br/><br/>// Convert the template into pure JavaScript<br/>str<br/>.replace(/[rtn]/g, " ")<br/>.split(")[^t]*)'/g, "$1r")<br/>.replace(/t=(.*?)%&gt;/g, "',$1,'")<br/>.split("t").join("');")<br/>.split("%&gt;").join("p.push('")<br/>.split("r").join("'")<br/>+ "');}return p.join('');");<br/><br/>// Provide some basic currying to the user<br/>return data ? fn( data ) : fn;<br/>};<br/>})();</pre>
<p>So whatâ€™s going on here? The template string input is being converted to raw JavaScript that, when executed, will return HTML. The â€œnew Function()â€ basically wraps that JS in an closure to be eval()â€™d if/when thereâ€™s data. If data was passed in to templ(), then the Function() is executed immediately and the result HTML is returned. if no data is passed in, then the Function is returned.</p>
<p>Iâ€™ll be honest, when I see String data being turned into code I shudder. I subscribe to the â€œdonâ€™t make it any more complicated than it needs to beâ€ paradigm, and storing code as data or vice versa does exactly that. It adds more complication for IMO no benefit. Also â€“ thereâ€™s the security risk. If you never mix code and data, then if your data becomes compromised or corrupted, you can still be 100% sure that your code is still safe. But if you mix code and data, and your data gets fudged, then your code is equally screwed.</p>
<p>Itâ€™s just good practice: data is data and code is code.</p>
<p>Luckily, one of <a href="http://ejohn.org/blog/javascript-micro-templating/#comment-318940">Resigâ€™s commenters, </a><a href="http://irae.pro.br/en/" rel="external nofollow">IraÃª</a><a href="http://ejohn.org/blog/javascript-micro-templating/#comment-318940">,</a> proposes in my view a much better (and safer) solution:</p>
<pre class="wp-block-preformatted">markup={};<br/>markup.user = function() {<br/>html='<br/>&lt;dl&gt;<br/>&lt;dt&gt;'+this.name+'&lt;/dt&gt;<br/>&lt;/dl&gt;<br/><br/>&lt;dl&gt;<br/>&lt;dd&gt;'+this.about+'&lt;/dd&gt;<br/>&lt;/dl&gt;<br/>';<br/>return html;<br/>}</pre>
<p>And to use it:</p>
<pre class="wp-block-preformatted">$('#output').html(markup.user.apply(data));</pre>
<p>This way is so much cleaner! The only Strings in this solution is the data itself, and the â€˜codeâ€™ of the template isâ€¦ JavaScript itself! Less confusing. Less code to write. Less security risk. Whatâ€™s not to like?</p>
<p>Last Thoughts:</p>
<p>I mentioned we had a use for this sort of thing when we built <a href="http://www.jotlet.net/">Jotlet</a>. So what did we do? We built classes for each of our UI elements. Code looked something like:</p>
<pre class="wp-block-preformatted">var taskRow = new TaskRow();<br/>taskRow.setTask(taskObj);<br/>document.body.appendChild(taskRow.getDOM());<br/>The DOM for that task could either be cached, or used for another task with a call to:<br/>taskRow.setTask(otherTaskObj);</pre>
<p>Itâ€™s a far different solution (and heavier weight) than whatâ€™s being talked about here. Iâ€™ll save details for another post ğŸ™‚</p>